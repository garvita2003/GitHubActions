# .github/workflows/streamlined-conditional-pipeline.yml

name: Computation

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  job-a:
    name: Job-A on ${{ matrix.runner }}
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        runner: [runner-a, runner-b] # Define our runners
    outputs:
      # Capture the success status for each specific runner
      runner-a-status: ${{ steps.set-result.outputs.runner-a-status }}
      runner-b-status: ${{ steps.set-result.outputs.runner-b-status }}
    steps:
      - name: Run Job-A logic
        run: |
          echo "Running Job-A on ${{ matrix.runner }}"
          # Simulate Job-A's work. A non-zero exit code here would fail the job.
          # For demonstration, we'll always succeed.
          # To simulate failure for a specific runner:
          # if [ "${{ matrix.runner }}" == "runner-a" ]; then exit 1; fi

      - name: Set result for ${{ matrix.runner }}
        id: set-result
        run: |
          # Dynamically set an output based on the runner, indicating success or failure.
          # job.status will be 'success', 'failure', 'cancelled', or 'skipped'.
          echo "${{ matrix.runner }}-status=${{ job.status }}" >> $GITHUB_OUTPUT

  job-b:
    name: Job-B on ${{ matrix.runner }}
    needs: job-a # Ensure Job-A completes for all matrix combinations before Job-B starts
    runs-on: ${{ matrix.runner }} # Uses self-hosted runners with specific labels
    strategy:
      matrix:
        runner: [runner-a, runner-b] # Re-define the runners for Job-B's matrix
    if: |
      (matrix.runner == 'runner-a' && needs.job-a.outputs.runner-a-status == 'success') ||
      (matrix.runner == 'runner-b' && needs.job-a.outputs.runner-b-status == 'success')
    steps:
      - run: echo "Running Job-B on ${{ matrix.runner }} because Job-A succeeded on the same runner"
