# .github/workflows/streamlined-conditional-pipeline.yml

name: Computation

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  job-a:
    name: Job-A on ${{ matrix.runner }}
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        runner: [ubuntu-latest, windows-latest] # Define our runners
    outputs:
      # Capture the success status for each specific runner
      runner-a-status: ${{ steps.set-result.outputs.ubuntu-latest-status }}
      runner-b-status: ${{ steps.set-result.outputs.windows-latest-status }}
    steps:
      - name: Run Job-A logic
        run: |
          echo "Running Job-A on ${{ matrix.runner }}"

      - name: Set result for ${{ matrix.runner }}
        id: set-result
        run: |
          echo "${{ matrix.runner }}-status=${{ job.status }}" >> $GITHUB_OUTPUT

  job-b:
    name: Job-B on ${{ matrix.runner }}
    needs: job-a # Ensure Job-A completes for all matrix combinations before Job-B starts
    runs-on: ${{ matrix.runner }} # Uses self-hosted runners with specific labels
    strategy:
      matrix:
        runner: [ubuntu-latest, windows-latest] # Re-define the runners for Job-B's matrix
    if: |
      (matrix.runner == 'ubuntu-latest' && needs.job-a.outputs.runner-a-status == 'success') ||
      (matrix.runner == 'windows-latest' && needs.job-a.outputs.runner-b-status == 'success')
    steps:
      - run: echo "Running Job-B on ${{ matrix.runner }} because Job-A succeeded on the same runner"
