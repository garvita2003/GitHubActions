# .github/workflows/perfectly_conditional_matrix.yml

name: Precisely Conditional Matrix Jobs

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allows manual triggering for easy testing

jobs:
  # Job 1: Runs Job-A on all specified OS runners.
  # It explicitly captures the final status of each individual run.
  job-a:
    name: Job-A on ${{ matrix.os_runner }}
    runs-on: ${{ matrix.os_runner }}
    strategy:
      fail-fast: false # Ensures all matrix jobs run even if one fails
      matrix:
        os_runner: [ubuntu-latest, macos-latest]
    outputs:
      # Outputs the status of each specific runner's Job-A execution.
      # These outputs are consumed by the 'aggregate-results' job.
      status_ubuntu: ${{ steps.capture_status.outputs.current_status }}
      status_macos: ${{ steps.capture_status.outputs.current_status }}
    steps:
      - name: Run Job-A logic
        run: |
          echo "Running Job-A logic on ${{ matrix.os_runner }}..."
          # --- SCENARIO: SIMULATE FAILURE FOR UBUNTU-LATEST ---
          if [ "${{ matrix.os_runner }}" == "ubuntu-latest" ]; then
            echo "Simulating a controlled failure for Job-A on ubuntu-latest."
            exit 1 # This makes this specific matrix instance of job-a fail.
          fi
          # --- END SCENARIO ---
          echo "Job-A on ${{ matrix.os_runner }} completed successfully."

      - name: Capture Individual Job-A Status for Output
        id: capture_status
        if: always() # This is crucial: ensures the status is captured even if 'Run Job-A logic' failed
        run: |
          # Use `github.job.status` to get the final status of the *current matrix instance* of job-a.
          echo "current_status=${{ github.job.status }}" >> $GITHUB_OUTPUT
          echo "Captured status for ${{ matrix.os_runner }}: ${{ github.job.status }}"

  # Job 2: Aggregates the results from Job-A's matrix runs.
  # This job's purpose is to create a single, consolidated list of
  # which OS runners succeeded in Job-A. This is the key to dynamic job-B creation.
  aggregate-results:
    name: Aggregate Job-A Successful Runners
    runs-on: ubuntu-latest # A general runner for this aggregation task
    needs: job-a # Depends on ALL instances of Job-A completing (success or failure)
    outputs:
      # Outputs a JSON array of *only* the OS runners that succeeded in Job-A.
      successful_runners_json: ${{ steps.filter_successful.outputs.json_list }}
    steps:
      - name: Filter Successful Runners
        id: filter_successful
        run: |
          # Initialize an empty array for successful runners
          SUCCESSFUL_RUNNERS_ARRAY="[]"

          # Check status for ubuntu-latest instance of job-a
          UBUNTU_STATUS="${{ needs.job-a.outputs.status_ubuntu }}"
          echo "Job-A Ubuntu status: $UBUNTU_STATUS"
          if [ "$UBUNTU_STATUS" == "success" ]; then
            # Add 'ubuntu-latest' to the array if its job-a instance succeeded
            SUCCESSFUL_RUNNERS_ARRAY=$(echo "$SUCCESSFUL_RUNNERS_ARRAY" | jq '. += ["ubuntu-latest"]')
          fi

          # Check status for macos-latest instance of job-a
          MACOS_STATUS="${{ needs.job-a.outputs.status_macos }}"
          echo "Job-A macOS status: $MACOS_STATUS"
          if [ "$MACOS_STATUS" == "success" ]; then
            # Add 'macos-latest' to the array if its job-a instance succeeded
            SUCCESSFUL_RUNNERS_ARRAY=$(echo "$SUCCESSFUL_RUNNERS_ARRAY" | jq '. += ["macos-latest"]')
          fi
          
          # Output the final JSON array. This is what Job-B will use.
          echo "Generated successful runners list: $SUCCESSFUL_RUNNERS_ARRAY"
          echo "json_list=$SUCCESSFUL_RUNNERS_ARRAY" >> $GITHUB_OUTPUT
        # jq is pre-installed on
